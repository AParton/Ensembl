#!/usr/bin/env perl

use strict;
use warnings;

BEGIN {
  use File::Basename;
  use File::Spec;
  my $dirname = dirname(__FILE__);
  my $lib = File::Spec->catdir($dirname, File::Spec->updir(), 'lib');
  if(-d $lib) {
    unshift(@INC, $lib);
  }
  else {
    die "Cannot find the lib directory in the expected location $lib";
  }
};

use Pod::Usage;
use Getopt::Long;
use Cwd;
use EnsEMBL::Git;

# This normally lives in ~ensembl/git-ensembl.groups or ~/git-ensembl.groups
my $CFG_FILE = 'git-ensembl.groups';
# All default ensembl repos have this public root
my $GITHUB_HTTPS_ROOT = 'https://github.com/Ensembl/';
my $GITHUB_SSH_ROOT = 'ssh://git@github.com/Ensembl/';

run();

sub run {
  my $opts = parse_command_line();
  if($opts->{list}) {
    run_list($opts);
    exit 0;
  }

  chdir $opts->{dir};
  foreach my $grp (@{$opts->{groups}}) {
    if($opts->{clone}) {
      run_clone($opts, $grp);
    }
    elsif($opts->{checkout}) {
      run_checkout($opts, $grp);
    }
    elsif($opts->{pull}) {
      run_pull($opts, $grp);
    }
    elsif($opts->{fetch}) {
      run_fetch($opts, $grp);
    }
  }
  exit 0;
}

sub parse_command_line {
  my $opts = {
    dir => cwd(),
    verbose => 1,
    help => 0,
    man => 0
  };

  GetOptions($opts, qw/
    clone
    checkout
    branch=s
    pull
    fetch
    dir=s
    groups
    list
    ssh
    server=s
    user|username=s
    github_user|github_username=s
    github_email=s
    help|?
    man
  /) or pod2usage(2);

  pod2usage(1) if $opts->{help};
  pod2usage(-exitval => 0, -verbose => 2) if $opts->{man};

  if($opts->{checkout} && ! $opts->{branch}) {
    pod2usage(-exitval => 1, -verbose => 1, -msg => 'You must a --branch when using --checkout');
  }

  # parsing grabbed the -- args so we're left with just the final groups
  if(! $opts->{list} && ! @ARGV) {
    pod2usage(-exitval => 1, -verbose => 1, -msg => 'No groups specified; please specify some');
  }
  $opts->{groups} = [map { lc($_) } @ARGV];
  return $opts;
}

sub run_clone {
  my ($opts, $group) = @_;

  _loop_modules($opts, $group, sub {
    my ($module, $remote) = @_;

    if ( -d $module) {
      print STDERR "! Skipping module as there is already a directory called that; try 'git ensembl --pull'\n";
      return;
    }

    my $usr = $opts->{user};
    if($remote =~ /^https/ && $usr) {
      print "* Using the HTTPS protocol with username $usr\n";
      $remote =~ s/github\.com/$usr\@github.com/;
    }
    my $ssh_srv = $opts->{server};
    if($remote =~ /^ssh/ && $ssh_srv) {
      print "* Using the SSH protocol with server $ssh_srv\n";
      $remote =~ s/github\.com/$ssh_srv/;
    }

    print "* Cloning from remote '${remote}'\n";
    if(! clone($remote, $opts->{verbose})) {
      print STDERR "! Failed to clone the module '$module'\n";
      return;
    }

    # Now deal with config variables
    if($opts->{github_user} || $opts->{github_email}) {
      chdir($module);
      print "* Setting user/email config variables\n";
      add_config('user.name', $opts->{github_user}) if $opts->{github_user};
      add_config('user.email', $opts->{github_email}) if $opts->{github_email};
      chdir(File::Spec->updir());
    }

    return;
  });

  return;
}

sub run_checkout {
  my ($opts, $group) = @_;
  my $branch = $opts->{branch};
  my $verbose = $opts->{verbose};
  _loop_modules_and_chdir($opts, $group, sub {
    print "* Fetching from origin before checking out\n";
    fetch($verbose);
    print "* Checking out branch '${branch}'\n";
    if(! checkout_tracking($branch, 'origin', $verbose)) {
      printf STDERR "! Cannot switch to ${branch}\n";
      return 0;
    }
    return;
  });
  return;
}

sub run_pull {
  my ($opts, $group) = @_;
  my $branch = $opts->{branch};
  my $verbose = $opts->{verbose};
  _loop_modules_and_chdir($opts, $group, sub {
    my ($module) = @_;
    if($branch) {
      print "* Switching branches before initating pull from origin\n";
      if(! checkout_tracking($branch, 'origin', $verbose)) {
        printf STDERR "! Cannot switch to ${branch}\n";
        return 0;
      }
    }

    print "* Performing pull\n";
    pull('origin', $verbose);

    return;
  });
  return;
}

sub run_fetch {
  my ($opts, $group) = @_;
  _loop_modules_and_chdir($opts, $group, sub {
    my ($module) = @_;
    print "* Performing fetch\n";
    fetch($opts->{verbose});
    return;
  });
  return;
}

sub run_list {
  my ($opts) = @_;
  my $all_groups = get_groups($opts);
  foreach my $group (sort keys %$all_groups) {
    my $definitions = $all_groups->{$group};
    printf("[%s] - %s\n", $group, $definitions->{desc});
    printf("\t%s (%s)\n", $_, $definitions->{modules}->{$_}) for sort keys %{$definitions->{modules}};
    print "\n";
  }
  return;
}

sub _loop_modules_and_chdir {
  my ($opts, $group, $callback) = @_;
  _loop_modules($opts, $group, sub {
    my ($module, $remote) = @_;
    if (! -d $module) {
      print STDERR "! Skipping module as there is no directory called that; try 'git ensembl --clone'\n";
      return;
    }
    chdir($module);
    if(is_git_repo()) {
      $callback->($module, $remote);
    }
    else {
      print STDERR "! Skipping '${module}' because it is not a Git directory\n";
    }
    chdir(File::Spec->updir());
    return;
  });
}

# Takes a group name and a callback. We grab the modules and for each one we ask 
# the callback to process the name and it's remote URL
sub _loop_modules {
  my ($opts, $group, $callback) = @_;
  printf "* Processing group '%s'\n\n", $group;
  my $modules = get_modules($opts, $group);
  if(! keys %{$modules}) {
    print "* Cannot find any modules. Check that this group was active using --list\n";
    return;
  }

  foreach my $module (sort keys %{$modules}) {
    printf "* Working with '%s'\n", $module;
    my $remote = $modules->{$module};
    $callback->($module, $remote);
    print "\n";
  }
  return;
}

# Loop through the remainder
sub verify_groups {
  my ($opts) = @_;
  my $groups = get_groups($opts);
  foreach my $group (@{$opts->{groups}}) {
    if(! exists $groups->{$group}) {
      pod2usage(-exitval => 1, -verbose => 1, -msg => "We do not understand the group '${group}'. Please use the --list command to see all available groups");
    }
  }
  return 1;
}

sub get_modules {
  my ($opts, $group) = @_;
  my $all_groups = get_groups($opts);
  return $all_groups->{$group}->{modules};
}

sub get_groups {
  my ($opts) = @_;
  my $default = _default_groups($opts);
  my $central = _central_groups($opts);
  my $user    = _user_groups($opts);
  return {
    %{$default},
    %{$central},
    %{$user},
  };
}

# Grab the user groups from $HOME/$CFG_FILE
sub _user_groups {
  my ($opts) = @_;
  my $my_home = (getpwuid($<))[7];
  my $file = File::Spec->catfile($my_home, $CFG_FILE);
  return {} unless -f $file;
  return json($file);
}

# Grab the central groups from $ENSHOME/$CFG_FILE
sub _central_groups {
  my ($opts) = @_;
  my $ens_home = (getpwnam('ensembl'))[7];
  my $file = File::Spec->catfile($ens_home, $CFG_FILE);
  return {} unless -f $file;
  return json($file);
}

# Provide the default groups
sub _default_groups {
  my ($opts) = @_;

  my $root = ($opts->{ssh}) ? $GITHUB_SSH_ROOT : $GITHUB_HTTPS_ROOT;

  my $core_api_modules = {
    'ensembl'           => $root.'ensembl.git',
    'ensembl-compara'   => $root.'ensembl-compara.git',
    'ensembl-variation' => $root.'ensembl-variation.git',
    'ensembl-funcgen'   => $root.'ensembl-funcgen.git',
  };

  return {
    temp => {
      desc => 'Temporary group reflecting currently available github based repos',
      modules => {
        'ensembl'           => $root.'ensembl.git',
        'ensembl-compara'   => $root.'ensembl-compara.git',
      }
    },
    api => {
      desc => 'API module set used for querying and processing Ensembl data',
      modules => $core_api_modules,
    },
    tools => {
      desc => 'Libraries required to run Ensembl tools such as the VEP',
      modules => {
        %{$core_api_modules},
        'ensembl-tools' => $root.'ensembl-tools.git'
      },
    },
    production => {
      desc => 'Libraries required to run Ensembl production',
      modules => {
        %{$core_api_modules},
        'ensembl-production' => $root.'ensembl-production.git',
        'ensembl-orm' => $root.'ensembl-orm.git',
      },
    },
    rest => {
      desc => 'Libraries required to run the Ensembl REST API',
      modules => {
        %{$core_api_modules},
        'ensembl-rest' => $root.'ensembl-rest.git',
      },
    },
    web => {
      desc => 'Libraries required to run the Ensembl website',
      modules => {
        %{$core_api_modules},
        'ensembl-webcode' => $root.'ensembl-webcode.git',
        'ensembl-draw' => $root.'ensembl-draw.git',
        'ensembl-orm' => $root.'ensembl-orm.git',
        'public-plugins' => $root.'public-plugins.git',
      },
    }
  };
}



__END__
=pod

=head1 NAME

git-ensembl - Ensembl-centric Git Utility

=head1 SYNOPSIS

git ensembl [--clone [--user USR] ] [--checkout --branch BRANCH] 
            [--pull] [--fetch] [--dir DIR] [--groups] [--list] 
            [-v] [-h] [-m] GROUPS

# List all available groups

git ensembl --list

# Clone all the API modules

git ensembl --clone api

# Clone as a specific GitHub user

git ensembl --clone --user myusr api

# Clone, use a new user and set a new Git username and email

git ensembl --clone --user myusr --github_user 'Name' 
  --github_email 'email@somewhere.com' api

# Clone using SSH and specify an alternative server name (see later for info about how to configure multiple GitHub accounts over SSH)

git ensembl --clone --ssh --server ensembl.github.com

# Pull in new changes (merges into each repo's current branch)

git ensembl --pull api

# Pull in new changes on the given branch

git ensembl --pull --branch master api

# Switch to a branch in all repos or create a new remote tracking branch

git ensembl --checkout --branch global/branch api

=head1 DESCRIPTION

Provides a number of convienience actions used to clone, switch branches & pull in new changes from remote Ensembl repositories. It also provides a way of addressing multiple repositories by a group name and applying the previously mentioned functions over those groups.

All repositories are cloned using HTTPS as since Git version 1.7.10 the HTTPS protocol has been significantly changed to be as efficient as the SSH and Git protocols.

B<If you are making a read/write clone make sure you specify your username via the --user command line argument. Otherwise Git will use your default authentication details.>

=head1 SCRIPT CONFIGURATION

This script ships with a number of default configurations. You can add to these if they are in the default global location C<~ensembl/git-ensembl.groups> or your home directory at C<~/git-ensembl.groups>. The format is a permissive JSON file (accepting comments and tollerant to formatting/trailing punctuation) like so:

    {
      "groupname" : {
        "desc" : "Group description",
        "modules" : {
          "module" : "giturl",
        }
      }
    }

For example:

    {
      "coretests" : {
        "desc" : "All the modules you need to get core modules working",
        "modules" : {
          "ensembl" : "https://github.com/Ensembl/ensembl.git",
          "ensembl-test" : "https://github.com/Ensembl/ensembl-test.git",
        }
      }
    }

Configuration is resolved in the following order

=over 8

=item * User configuration

=item * Central configuration

=item * Default configuration

=back

When a clashing group is named the higher priority group takes precedence.

=head1 GIT REMOTE CLONE CONFIGURATION

B<PLEASE ONLY READ THIS IF YOU NEED WRITE ACCESS TO REPOSITORIES>

This script uses two Git transport mechanisms; HTTPS and SSH. Please see the following two sections about how to configure both for read/write access. Make sure you clone using the B<--github_user> and B<--github_email> should you not want to clone using your default Git username and email.

=head2 HTTPS

By default this script clones using HTTPS. We normally clone using the base URL B<https://github.com/>. This uses your default username and password. If you have never specfiied these Git will ask for them on your first clone.

Should you need to use another user account you can give a different username. You must run this script using the B<--user> command argument.

=head2 SSH

You can switch to SSH using the B<--ssh> command. By default the server is github.com but you can change this by using the B<--server> command line argument.

=head3 SSH CONFIG

Here we have configured two hostnames and have associcated a different SSH key to each one. You can follow the guide about how to generate a new SSH key and add it to your GitHub account from here https://help.github.com/articles/generating-ssh-keys

    Host github.com
      HostName github.com
      PreferredAuthentications publickey
      IdentityFile ~/.ssh/id_rsa_github
      User git

    Host ensembl.github.com
      HostName github.com
      PreferredAuthentications publickey
      IdentityFile ~/.ssh/id_rsa_github_ensembl
      User git

=head1 OPTIONS

=over 8

=item B<GROUPS>

The groups to perform actions on. Use B<--list> to find all available groups

=item B<--clone>

Clone the repositories linked to the given group (Ensembl's remote hosted on GitHub)

=item B<--user | --username>

The username to use when cloning from HTTPS

=item B<--ssh>

Use the SSH protocol for cloning rather than HTTPS. HTTPS is the default clone protocol

=item B<--server>

Use the following server for cloning in preference to B<github.com>

=item B<--github_user | --github_username>

Set the config variable B<user.name> for this clone.

=item B<--github_email>

Set the config variable B<user.email> for this clone.

=item B<--checkout>

Checkout the branch specified in the B<--branch> command

=item B<--branch>

Branch to switch to. Used in conjunction with the B<--checkout> and B<--pull> commands

=item B<--pull>

Perform a pull from origin (Ensembl's remote hosted on GitHub)

=item B<--dir>

Perform all commands in the given directory

=item B<--list>

List all available groups

=item B<--help>

Print the help information

=item B<--man>

Print a man page

=back

=cut