#!/usr/bin/env perl

use strict;
use warnings;

BEGIN {
  use Cwd;
  use File::Basename;
  use File::Spec;
  my $dirname = dirname(Cwd::realpath(__FILE__));
  my $lib = File::Spec->catdir($dirname, File::Spec->updir(), 'lib');
  if(-d $lib) {
    unshift(@INC, $lib);
  }
  else {
    die "Cannot find the lib directory in the expected location $lib";
  }
};

use EnsEMBL::Git qw/clone fetch/;
use Pod::Usage;
use Getopt::Long;
use JSON;
use HTTP::Tiny;

my $base_url = 'https://api.github.com';
my $http = HTTP::Tiny->new();

run();

sub run {
  my $opts = parse_command_line();
  sync_repos($opts);
  return;
}

sub sync_repos {
  my ($opts) = @_;
  my $repos = get_repos($opts);
  foreach my $repo (@{$repos}) {
    my $name = $repo->{name};
    my $url = $repo->{clone_url};
    print "* Working with $name\n" if $opts->{verbose};
    my $dir = File::Spec->catdir($opts->{dir}, $name);
    my $action;
    if(! -d $dir) {
      print "* $dir does not exist; cloning repo rather than fetching\n" if $opts->{verbose};
      if( ! $opts->{'dry-run'}) {
        clone($url, $opts->{verbose}) or die 'Cannot clone repo '.$name; 
      }
    }
    else {
      print "* Fetching new information from repo (code and tags)\n" if $opts->{verbose};
      if(! $opts->{'dry-run'}) {
        my $cwd = cwd();
        chdir $dir;
        fetch(undef, $opts->{verbose}) or die 'Cannot fetch new commits for '.$name;
        fetch('tags', $opts->{verbose}) or die 'Cannot fetch tags for '.$name;
        chdir $cwd;
      }
    }
  }
}

sub get_repos {
  my ($opts) = @_;
  my $organisation = $opts->{organisation};
  my $repos = get_json($opts, "/orgs/${organisation}/repos", 'GET');
  return $repos unless @{$opts->{repository}};
  my %lookup = map { $_, 1 } @{$opts->{repository}};
  return [ grep { $lookup{$_->{name}} } @{$repos} ];
}

sub get_json {
  my ($opts, $url, $method) = @_;
  my $options = { headers => { } };
  my $response = $http->request($method, $base_url.$url, $options);
  die "Failed to fetch (${url})! STATUS: $response->{status} REASON: $response->{reason}\n" unless $response->{success};
  return decode_json($response->{content});
}

sub parse_command_line {
  my $opts = {
    repository => [],
    organisation => 'Ensembl',
    help => 0,
    man => 0
  };

  GetOptions($opts, qw/
    repository|repo=s@
    dir|directory=s
    organisation|organization=s
    dry-run
    verbose
    help|?
    man
  /) or pod2usage(2);

  pod2usage(1) if $opts->{help};
  pod2usage(-exitval => 0, -verbose => 2) if $opts->{man};

  if(!$opts->{dir}) {
    pod2usage(-exitval => 1, -verbose => 1, -msg => 'You must specify a --directory to work with');
  }

  return $opts;
}
__END__
=pod

=head1 NAME

github-sync - Sync an organisation's repositories

=head1 SYNOPSIS

github-sync --directory DIR [--organisation ORG] [--repository REPO] [--dry-run] [-h] [-m]

# Sync all repos in current dir

github-sync --directory $PWD

# Sync a selection

github-sync --directory $PWD --repository ensembl-hive

# Dry run with chatter

github-sync --directory $PWD --dry-run --verbose

=head1 DESCRIPTION

A script to pull down all available repositories from a GitHub organisation and attempts to pull the latest set of commits down from the remote GitHub repositories.

=head1 OPTIONS

=over 8

=item B<--directory>

Specify the directory to synchronize against

=item B<--organisation|organization>

The GitHub organisation to list repositories for. Defaults to Ensembl

=item B<--repository|repo>

The repository to use. If not specified we use all public repositories

=item B<--dry-run>

Do not fetch or clone

=item B<--help>

Print the help information

=item B<--man>

Print a man page

=back

=cut
